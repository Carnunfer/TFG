(*<*) 
theory CancelacionSobreyectiva 
imports Main "HOL-Library.LaTeXsugar" "HOL-Library.OptionalSugar" 
begin
(*>*) 

section \<open>Cancelación de las funciones sobreyectivas\<close>

text \<open>
El siguiente teorema prueba una propiedad de las funciones
 sobreyectivas. El enunciado es el siguiente: 
\begin {teorema}
Las funciones sobreyectivas son cancelativas por la derecha. Es decir,
 si f es sobreyectiva entonces para todas funciones g y h tal que g o f
 = h o f se tiene que g = h.
\end {teorema}
 
\begin {demostracion}
\begin {itemize}
\item Supongamos que tenemos que $g o f = h o f$, queremos probar que $g =
 h.$
$$(g o f)(x) = (h o f)(x) \Longrightarrow g(f(x)) = h(f(x))
 \stackrel{usando la def de sobreyectividad}{\Longrightarrow} g(y) =
 h(y).$$
\item Supongamos que $g = h$, hay que probar que $g o f = h o f.$
$$ (g o f)(x) = g(f(x)) \stackrel{por def de sobreyectividad}{=} g(y)
 \stackrel{por hip}{=} h(y) = h(g(x)).$$
\end {itemize}
.
\end {demostracion}

Su especificación es la siguiente: 
\<close>

lemma "surj f \<Longrightarrow> ( g \<o> f = h \<o> f ) = (g = h)"
  oops

  text \<open>
En la especificación anterior, @{term "surj f"} es una abreviatura de 
  @{term "range f = UNIV"}, donde @{term "range f"} es el rango o imagen
de la función f.
 Por otra parte, @{term UNIV} es el conjunto universal definido en la 
  teoría \href{http://bit.ly/2XtHCW6}{Set.thy} como una abreviatura de 
  @{term top} que, a su vez está definido en la teoría 
  \href{http://bit.ly/2Xyj9Pe}{Orderings.thy} mediante la siguiente
  propiedad 
  \begin{itemize}
    \item[] @{thm[mode=Rule] ordering_top.extremum[no_vars]} 
      \hfill (@{text ordering_top.extremum})
  \end{itemize} 
Además queda añadir que la teoría donde se encuentra definido @{term"surj f"}
 es en \href{http://bit.ly/2XuPQx5}{Fun.thy}. Esta teoría contiene la
 definicion @{term" surj_def"}.
 \begin{itemize}
    \item[] @{thm[mode=Rule] surj_def[no_vars]} \hfill (@{text inj_on_def})
  \end{itemize} 

Presentaremos distintas demostraciones del teorema. La primera es la
 aplicativa:
\<close>
lemma "surj f \<Longrightarrow> ( g \<o> f = h \<o> f ) = (g = h)"
  apply (simp add: surj_def fun_eq_iff)
  oops

(*<*)
end 
(*>*)